{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#nansen-neuro-analysis-software-ensemble","title":"NANSEN - Neuro ANalysis Software ENsemble","text":"<p>A collection of apps and modules for processing, analysis and visualization of two-photon imaging data. Check out the introduction to Nansen on YouTube and/or see the Wiki for more details.</p> <p></p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Installation</li> <li>Apps<ul> <li>Imviewer</li> <li>Fovmanager</li> </ul> </li> <li>Plugins</li> <li>Wiki</li> </ul>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>The NANSEN toolbox is still under development, so don't be surprised if you find occasional bugs here and there! If you manage to break something, please report under the issues section! Also, suggestions for improvements and general feedback are very welcome!</p>"},{"location":"#installation","title":"Installation","text":"<p>1) Clone the repository and add all subfolders to MATLAB's search path.   2) Make sure the required MATLAB toolboxes (listed below) are installed.  3) Run <code>nansen.setup</code> to install community toolboxes and configure your first project. Alternative: To use nansen apps without creating a project, install the required community toolboxes (listed below). View demo of <code>nansen.setup</code> on YouTube.</p>"},{"location":"#required-matlab-toolboxes","title":"Required Matlab toolboxes","text":"<ul> <li>Image Processing Toolbox</li> <li>Statistics and Machine Learning Toolbox</li> <li>Parallel Computing Toolbox</li> </ul> <p>To check if these toolboxes are already installed, use the <code>ver</code> command.  Typing <code>ver</code> in matlab's command window will display all installed toolboxes.  If any of the above toolboxes are not installed, they can be installed by  navigating to MATLAB's Home tab and then selecting Add-Ons &gt; Get Add-Ons</p>"},{"location":"#required-community-toolboxes","title":"Required community toolboxes","text":"<p>- Widgets Toolbox** (Download toolbox installer |\u00a0View toolbox site)</p> <p>** The Widgets Toolbox can also be installed using MATLAB's addon manager,  but it is important to install a compatibility version (v1.3.330) of the  toolbox, so please use the download link above or install using <code>nansen.setup</code>.</p>"},{"location":"#apps","title":"Apps","text":""},{"location":"#imviewer","title":"Imviewer","text":"<p>App for viewing and interacting with videos &amp; image stacks</p> <p></p>"},{"location":"#fovmanager","title":"Fovmanager","text":"<p>App for registering cranial implants, injection spots and imaging field of views (and RoIs) on an atlas of the dorsal surface of the cortex.</p> <p> </p>"},{"location":"#plugins","title":"Plugins","text":"<p>Example of toolbox plugins that are included in NANSEN</p> <p></p>"},{"location":"basics/","title":"Basics","text":"<p>Most of the data management and organization in Nansen relies on the concepts listed in the sections below. The following image shows a test project with multiple sessions as it appears in the Nansen App. The user can select sessions in the app and run different methods and community toolboxes on their data. By implementing DataLocationModels and VariableModels, Nansen can run these methods and toolboxes regardless of how the data is saved and organised on the file system.</p> <p></p>"},{"location":"basics/#projects","title":"Projects","text":"<p>A user creates one or several projects to manage collections of experimental sessions. An experimental session is defined as one continuous recording of data from a single or multiple recording systems. A project should ideally consist of a fairly homogeneous set of sessions, i.e same type of recordings and similar protocols used, but in the end it is up to the user to decide how to organize a project. To manage projects, run <code>nansen.ProjectManager</code></p> <p>The name of the project will be used to create a namespace (or package folder) in Matlab, so it is required that the name is a valid variable name (i.e consist of letters and underscores) and recommended that it is short and concise. </p> <p>Users can create their own table variables and session methods (more on this below) and these will be added to the project's namespace. In this way, session methods and table variables can be adapted to meet project-specific demands, while also retaining the same names across different projects.</p>"},{"location":"basics/#data-locations","title":"Data Locations","text":"<p>A typical experiment might include data from different recording systems as well as different stages of processing. Each of these constitutes a Data Location. For example, when doing two-photon experiments, one computer is typically dedicated to the image acquisition whereas another computer is controlling the behavioural setup and recording behavior-related variables. These would be represented as different data locations, i.e \"Rawdata_twophoton\" and \"Rawdata_behavior\". </p> <p>In Nansen, the user will use the <code>nansen.setup</code> application to create a DataLocationModel for each project. The DataLocationModel is configured so that Nansen can locate folders containing session data (session folders) from all the different Data Locations and match them to specific sessions. This includes specifying the root directory where data is located, as well as the subfolder organization of data. Once a DataLocationModel is properly configured, all the session folders from different Data Locations are accessible from a <code>Session</code> object (more about session objects below).</p>"},{"location":"basics/#variables","title":"Variables","text":"<p>When working with Nansen, a key principle is that the user should not have to interact directly with files, but instead with data variables. A very short example workflow could look like this:</p> <p><pre><code>twoPhotonImageStack = mySession.loadData('TwoPhotonSeries')\nmotionCorrectedStack = nansen.wrapper.normcorre.Processor(twoPhotonImageStack)\n</code></pre> (Note: To run motion correction in Nansen, it is better to run it from the menu in the Nansen app)</p> <p>In order to make this work the user has to create a VariableModel. This is initially done during the initial project setup, but the VariableModel can be updated interactively at any time. The VariableModel maps a file (or a set of files) to a data variable and contains instructions on how to read and write data from the file. For the example above to work, there need to be a variable called \"TwoPhotonSeries\" and the model needs to know where to find that variable and how to read it. This is achieved by linking the variable to a file by specifying a pattern which should uniquely identify the file containing two-photon data and by specifying a file adapter  to use for reading the data. </p> <p>Nansen provides file adapters for some common microscope formats (PrairieView, SciScan, ScanImage, more to come) and therefore it does not matter how the data is stored on the drive. ScanImage saves data to tiff stacks, SciScan saves data to binary files, PrairieView saves data to individual tiff files, etc, and the job of the file adapter's is to load the data into a standard data type that can be passed on to a processing method.</p> <p>In practice, this means that opening a TwoPhotonSeries for any session, regardless of which recording system is used, the following command is used: <code>twoPhotonImageStack = mySession.loadData('TwoPhotonSeries')</code>.</p> <p>Some data variables are predefined in Nansen, e.g variables related to two-photon data, rois and extracted fluorescence series, but the user can easily add any experimental files as custom Variables. Custom file adapters (m-files) can be dragged and dropped into Nansen, and a hopeful scenario is that users can share file adapters and thereby spend less time writing custom code to load data into their specific pipelines, but instead write session methods for working on standardised data variables.</p>"},{"location":"basics/#session-table-and-session-objects","title":"Session table and <code>Session</code> objects","text":"<p>Once a DataLocationModel is created, Nansen can detect folders with experimental data from sessions and create a table of sessions. Each session is represented using a <code>Session</code> object. All the variables that are specified in the VariableModel is then accessible on a <code>Data</code> property of the session object. </p> <p>In the nansen app, all sessions are listed in a session table, where the user can sort sessions or filter sessions according to different criteria. Sessions can also be added to collections, which is useful when working with a subset of sessions. The user can also create custom table (or session info) variables which are added to the table. These table variables can either get their values from manual inputs, or the user can write custom functions for retrieving values that are session specific. Furthermore, custom table variables (m-files) can easily be shared with others and included to projects.</p> <p>Also, the session table provides an interface to running processing / analysis methods on sessions and building processing pipelines. Nansen comes with many methods for processing two photon data, and these can be combined into custom pipelines. The user can select sessions in the app and run methods or pipelines for these sessions. The user can also create custom session methods which is instantly integrated into the app and can be shared across projects and with other users.</p>"},{"location":"index_orig/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index_orig/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index_orig/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"test/","title":"Basics","text":""},{"location":"tutorials/","title":"Avanced","text":"<pre><code>function combinedListing = recursiveDir(rootPath, options)\n\n    arguments\n        rootPath (1,:) string\n        options.IgnoreList (1,:) string = string.empty\n        options.Expression (1,1) string = \"\"\n        options.Type (1,1) string {mustBeMember(options.Type, {'file', 'folder', 'all'})} = \"all\"\n        options.FileType (1,1) string = \"\"\n        options.RecursionDepth (1,1) double = inf\n        options.IsCumulative (1,1) logical = true\n        options.OutputType (1,1) string {mustBeMember(options.OutputType, {'FilePath', 'FileAttributes'})} = 'FileAttributes'\n        options.IncludeHiddenFiles = false\n    end\n\n    import utility.dir.recursiveDir\n\n    combinedListing = utility.dir.empty();\n\n    % Get the OutputType and change to FileAttributes. Any internal \n    % (recursive) call to recursiveDir need to return data as\n    % FileAttributes.\n    outputType = options.OutputType;\n    options.OutputType = 'FileAttributes';\n\n    if numel(rootPath) &gt; 1\n        for i = 1:numel(rootPath)\n            nvpairs = utility.struct2nvpairs(options);\n            newListing = recursiveDir(rootPath(i), nvpairs{:});\n            combinedListing = cat(1, combinedListing, newListing);\n        end\n    else\n        % Find folders in root path\n        newListing = dir(fullfile(rootPath));\n\n        % 1. Remove \"shadow\" files / hidden files\n        newListing(strcmp({newListing.name}, '.')) = [];\n        newListing(strcmp({newListing.name}, '..')) = [];\n\n        if ~options.IncludeHiddenFiles\n            newListing(strncmp({newListing.name}, '.', 1)) = [];\n        end\n\n        % 2. Filter listing by exclusion criteria\n        keep = true(1, numel(newListing));\n\n        % Remove folders that contain a word from the ignore list.\n        if ~isempty(options.IgnoreList)\n            ignore = contains({newListing.name}, options.IgnoreList);\n            keep = keep &amp; ~ignore;\n        end\n\n        filteredListing = newListing(keep);\n        keep = true(1, numel(filteredListing)); \n\n        % 3. Keep only list items that matches expression\n        if options.Expression ~= \"\"\n            isValidName = @(fname) ~isempty(regexp(fname, options.Expression, 'once'));\n            isMatch = cellfun(@(name) isValidName(name), {newListing.name} );\n            keep = keep &amp; isMatch;\n        end\n\n        % 4. Select only files or folders if this is an option\n        if options.Type == \"file\"\n            keep = keep &amp; ~[filteredListing.isdir];\n        elseif options.Type == \"folder\"\n            keep = keep &amp; [filteredListing.isdir];\n        end\n\n        % 5. Filter by filetype if this is an option\n        if options.FileType ~= \"\" &amp;&amp; ~strncmp(options.FileType, '.', 1)\n            options.FileType = sprintf('.%s', options.FileType);\n        end\n\n        if options.FileType ~= \"\"\n            [~, ~, ext] = fileparts({filteredListing.name});\n            isValidFiletype = strcmp(ext, options.FileType);\n            keep = keep &amp; isValidFiletype;\n        end\n\n        keepListing = filteredListing(keep);\n        if ~isempty(keepListing)\n            combinedListing = cat(1, combinedListing, keepListing);\n        end\n\n        options.RecursionDepth = options.RecursionDepth - 1;\n\n        if options.RecursionDepth &gt; 0 &amp;&amp; sum([filteredListing.isdir]) &gt; 0\n            % Continue search through subfolders that passed the filter\n            newRootPath = arrayfun(@(l) string(fullfile(l.folder, l.name)), filteredListing, 'uni', 1);\n            newRootPath(~[newListing.isdir])=[];\n\n            nvpairs = utility.struct2nvpairs(options);\n            subListing = recursiveDir(newRootPath, nvpairs{:});\n            if ~isempty(subListing)\n                if options.IsCumulative\n                    combinedListing = cat(1, combinedListing, subListing);\n                else\n                    combinedListing = subListing;\n                end\n            end\n        end\n    end\n\n    if outputType == \"FilePath\"\n        combinedListing = utility.dir.abspath(combinedListing);\n    end\nend\n</code></pre>"}]}